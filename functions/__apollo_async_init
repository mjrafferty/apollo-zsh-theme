# vim:ft=zsh

typeset -gi __APOLLO_ASYNC
typeset -g  __APOLLO_ASYNC_BUFFER_NAME
typeset -gi __APOLLO_ASYNC_BUFFER_FD
typeset -ga __APOLLO_ASYNC_MODULES
typeset -g  __APOLLO_ASYNC_MANAGER_PID
typeset -gA __APOLLO_ASYNC_RESULTS

__apollo_async_worker(){

  local module="$1"

  "__apollo_${module}_async"

  echo "${module};${__APOLLO_RETURN_MESSAGE}" >&"${__APOLLO_ASYNC_BUFFER_FD}"

  kill -USR1 "${__APOLLO_PROMPT_PID}"

}

__apollo_async_catch_signal() {

  local module

  for module in "${__APOLLO_ASYNC_MODULES[@]}"; do
    __apollo_async_worker "$module" &
  done

}

__apollo_async_manager() {

  trap "__apollo_async_catch_signal" USR2

  typeset -gi __APOLLO_PROMPT_PID

  __APOLLO_PROMPT_PID="$1"

# Run until killed by prompt
  while true; do
    sleep 1;
  done

}

__apollo_async_manager_start() {

  if [[ -z "$__APOLLO_ASYNC_MANAGER_PID" ]] || ! kill -0 "$__APOLLO_ASYNC_MANAGER_PID" &> /dev/null; then
    __apollo_async_manager $$ &!
    __APOLLO_ASYNC_MANAGER_PID="$!"
  fi

}

__apollo_async_results() {

  local result
  local -a results

  while read -rt result <&"${__APOLLO_ASYNC_BUFFER_FD}"; do
    results=(${(s.;.)result})
    __APOLLO_ASYNC_RESULTS[$results[1]]="${results[2]}"
    __apollo_async_update "${results[1]}"
  done

}

__apollo_async_start() {}
__apollo_async_stop() {}
__apollo_async_pause() {}
__apollo_async_resume() {}

__apollo_async_cleanup () {

  kill "$__APOLLO_ASYNC_MANAGER_PID" &> /dev/null

  exec {__APOLLO_ASYNC_BUFFER_FD}>&-
  rm "$__APOLLO_ASYNC_BUFFER_NAME"

}

__apollo_async_init() {

  __APOLLO_ASYNC_BUFFER_NAME="${TMPDIR:-/tmp}/${USER}__APOLLO_ASYNC_$EPOCHSECONDS"
  mkfifo "${__APOLLO_ASYNC_BUFFER_NAME}"
  exec {__APOLLO_ASYNC_BUFFER_FD}<> "${__APOLLO_ASYNC_BUFFER_NAME}"

  __apollo_async_manager_start;

  trap "__apollo_async_results" USR1
  add-zsh-hook zshexit __apollo_async_cleanup

}

__apollo_async_init "$@"
